#!/usr/bin/env node
var fs = require('fs');
var program = require('commander');
var async = require('async');
var bsw = require('./lib/bsw');
var _ = require('underscore');
//
// takes a file containing ip address until we write a ip address parser
// that will suck
//
program
  .version('0.0.1')
  .usage('[options] <ip file>')
  .option('-c, --concurrency <int>', 'limit amount of asynchronous requests')
  .option('-d, --dictionary <file>', 'hostname guessing using a one host per line dictionary')
  .option('-t, --target <domain>', 'domain to use')
  .option('-r, --reverse', 'reverse name lookup')
  .option('-s, --ssl', 'grab names from ssl certificates')
  .option('-b, --bing', 'search bing for vhosts')
  .option('-w, --web', 'grab names from DNS websites (i.e., robtex, serversniff)')
  .option('-f, --fcrdns', 'perform forward confirmed rDNS and return compliant names')
  .option('--headers', 'parse http and https response headers for hostnames')
  .option('--csv', 'output to csv')
  .option('--clean', 'ouput clean data')
  .option('--json', 'output a json object')
  .parse(process.argv);

if (!program.args[0] && !program.dictionary) { 
  croak('no ip file provided');
}

// concurrency gets set to 1000, that's healthy, but you could probably increase the amount
var concurrency = program.concurrency ? program.concurrency : 1000;
if (program.args[0]) {
  var ips = fs.readFileSync(program.args[0]).toString().split("\n");
  ips.pop();
}

var tasks = [];
if (program.dictionary) {
  if (!program.target) {
    croak('dictionary attack requires target domain');
  }
  var items = fs.readFileSync(program.dictionary).toString().split("\n");
  tasks.push(function(callback) { 
    bsw.dictionary(program.target, items, concurrency, function(results) {
      callback(null, results);
    });
  });
}

if (program.reverse) {
  tasks.push(function(callback) { 
    bsw.reverse(ips, concurrency, function(results) {
      callback(null, results);
    });
  });
}

if (program.ssl) {
  tasks.push(function(callback) {
    bsw.cert(ips, concurrency, function(results) {
      callback(null, results);
    });
  });
}

if (program.bing) {
  tasks.push(function(callback) {
    bsw.bing(ips, concurrency, function(results) {
      callback(null, results);
    });
  });
}

if (program.web) {
  tasks.push(function(callback) {
    bsw.robtex(ips, concurrency, function(results) {
      callback(null, results);
    });
  });
  tasks.push(function(callback) {
    bsw.serversniff(ips, concurrency, function(results) {
      callback(null, results);
    });
  });
}

if (program.headers) {
  tasks.push(function(callback) {
    bsw.headersHttp(ips, concurrency, function(results) {
      callback(null, results);
    });
  });
  tasks.push(function(callback) {
    bsw.headersHttps(ips, concurrency, function(results) {
      callback(null, results);
    });
  });
}

var now = new Date();
console.error('bsw started at', now);

async.parallel(tasks, function(err, results) {
  if (err) {
    console.log(err);
  }
  else {
    var now = new Date();
    console.error('bsw finished at', now);
    results = _.flatten(results);
    if (program.fcrdns) {
      bsw.fcrdns(results, concurrency, function(cleanResults) {
        output(cleanResults);
      });
    }
    else {
      output(results);
    }
  }
});

// output
function output(results)  {
  sorted = {};
  
  if (program.csv) { 
    outcsv(results);
  }

  else if (program.clean) {
    sort();
    outclean(sorted);
  }
    
  else if (program.json) {
    sort();
    outjson(sorted);
  }

  else {
    results.forEach(function(record) {
      if (record.ip) {
        console.log('name:', record.name, 'ip:', record.ip, 'method:', record.src);
      }
    });
  }
  process.exit(0);

  function sort() {
    results.forEach(function(record) {
      // when we flatten the arrays they well leave an empty object if no results
      if (record.ip) {
        if (sorted[record.ip]) {
          sorted[record.ip].push(record.name);
        }
        else {
          sorted[record.ip] = [record.name];
        }
      }
    });
    for (var k in sorted) {
      sorted[k] = _.uniq(sorted[k]);
    }
  }
}

function outcsv(results) {
  results.forEach(function(record) {
    if (record.ip) {
      console.log(record.name + ',' +  record.ip + ',' + record.src);
    }
  });
}

function outjson(sorted) {
  jsonout= [];
  for (var k in sorted) {
    jsonout.push({ "ip": k, "names": sorted[k] });   
  }
  console.log(JSON.stringify(jsonout, null, " "));
}

function outclean(sorted) {
  for (var k in sorted) {
    console.log(k + ':');
    sorted[k].forEach(function(element) {
      console.log('   ', element);
    });
  }
}

//
// generic function to print and exit
//
function croak(errorMessage) {
  console.log(errorMessage);
  process.exit(1);
}
