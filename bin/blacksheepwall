#!/usr/bin/env node
var fs = require('fs');
var program = require('commander');
var async = require('async');
var bsw = require('../lib/bsw');

//
// takes a file containing ip address until we write a ip address parser
// that will suck
//
program
  .version('0.0.1')
  .usage('[options] <ip file>')
  .option('-c, --concurrency <int>', 'limit amount of asyncrounous requests')
  .option('-d, --dictionary <file>', 'hostname guessing using a one host per line dictionary')
  .option('-t, --target <domain>', 'domain to use')
  .option('-r, --reverse', 'reverse name lookup')
  .option('-s, --ssl', 'grab names from ssl certificates')
  .option('-b, --bing', 'search bing for vhosts')
  .option('-o, --robtex', 'grab name records from robtex')
  .option('-f, --fcrdns', 'perform forward confirmed rDNS and return compliant names')
  .option('-h, --headers', 'parse http and https response headers for hostnames')
  .parse(process.argv);

if (!program.args[0] && !program.dictionary) { 
  croak('no ip file provided');
}

// concurrency gets set to 1000, that's healthy, but you could probably increase the amount
var concurrency = program.concurrency ? program.concurrency : 1000;
var resultsDb = {};
var ips = fs.readFileSync(program.args[0]).toString().split("\n");
ips.pop();

var tasks = [];
if (program.dictionary) {
  if (!program.target) {
    croak('dictionary attack requires target domain');
  }
  var items = fs.readFileSync(program.dictionary).toString().split("\n");
  tasks.push(function(callback) { 
    bsw.dictionary(program.target, items, concurrency, function(results) {
      results['src'] = 'dictionary';
      callback(null, results);
    });
  });
}

if (program.reverse) {
  tasks.push(function(callback) { 
    bsw.reverse(ips, concurrency, function(results) {
      results['src'] = 'reverse';
      callback(null, results);
    });
  });
}

if (program.ssl) {
  tasks.push(function(callback) {
    bsw.cert(ips, concurrency, function(results) {
      results['src'] = 'ssl-cert';
      callback(null, results);
    });
  });
}

if (program.bing) {
  tasks.push(function(callback) {
    bsw.bing(ips, concurrency, function(results) {
      results['src'] = 'bing';
      callback(null, results);
    });
  });
}

if (program.robtex) {
  tasks.push(function(callback) {
    bsw.robtex(ips, concurrency, function(results) {
      results['src'] = 'robtex';
      callback(null, results);
    });
  });
}

if (program.headers) {
  tasks.push(function(callback) {
    bsw.headersHttp(ips, concurrency, function(results) {
      results['src'] = 'header-http';
      callback(null, results);
    });
  });
  tasks.push(function(callback) {
    bsw.headersHttps(ips, concurrency, function(results) {
      results['src'] = 'header-https';
      callback(null, results);
    });
  });
}

async.parallel(tasks, function(err, results) {
  // build db
  for (var r = 0; r < results.length ; r++) {
    for (var i = 0; i < ips.length; i++) {
      if (results[r][ips[i]]) {
        if (!resultsDb[ips[i]]) {
          resultsDb[ips[i]] = {};
          resultsDb[ips[i]].src = [];
        }
        resultsDb[ips[i]][results[r].src] = results[r][ips[i]];
        resultsDb[ips[i]].src.push(results[r].src);
      }
    }
  }

  // TODO: process all results here
  /*if (program.fcrdns) {
    bsw.fcrdns(ips, results, concurrency, function(fcResults) {
      console.log(fcResults);
    });
  }*/

  // output csv
  for (var i = 0; i < ips.length; i++) {
    if (resultsDb[ips[i]]) {
      var sources = resultsDb[ips[i]].src;
      for (var s = 0; s < sources.length; s++) {
        for (var n = 0; n < resultsDb[ips[i]][sources[s]].length; n++) {
          console.log( 
                       ips[i] + ',' + 
                       resultsDb[ips[i]][sources[s]][n] + ',' + 
                       sources[s]
                     );
        }
      }  
    }
  }  

//  console.log(resultsDb);
  console.log('complete');
  process.exit(0);
});

//
// generic function to print and exit
//
function croak(errorMessage) {
  console.log(errorMessage);
  process.exit(1);
}
